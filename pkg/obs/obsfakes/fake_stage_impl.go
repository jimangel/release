/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package obsfakes

import (
	"sync"

	semver "github.com/blang/semver/v4"
	"k8s.io/release/pkg/gcp/gcb"
	"k8s.io/release/pkg/obs/specs"
	"k8s.io/release/pkg/release"
)

type FakeStageImpl struct {
	AddRemoveChangesStub        func(string, string, string) error
	addRemoveChangesMutex       sync.RWMutex
	addRemoveChangesArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	addRemoveChangesReturns struct {
		result1 error
	}
	addRemoveChangesReturnsOnCall map[int]struct {
		result1 error
	}
	BranchNeedsCreationStub        func(string, string, semver.Version) (bool, error)
	branchNeedsCreationMutex       sync.RWMutex
	branchNeedsCreationArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 semver.Version
	}
	branchNeedsCreationReturns struct {
		result1 bool
		result2 error
	}
	branchNeedsCreationReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CheckPrerequisitesStub        func(string) error
	checkPrerequisitesMutex       sync.RWMutex
	checkPrerequisitesArgsForCall []struct {
		arg1 string
	}
	checkPrerequisitesReturns struct {
		result1 error
	}
	checkPrerequisitesReturnsOnCall map[int]struct {
		result1 error
	}
	CheckoutProjectStub        func(string, string) error
	checkoutProjectMutex       sync.RWMutex
	checkoutProjectArgsForCall []struct {
		arg1 string
		arg2 string
	}
	checkoutProjectReturns struct {
		result1 error
	}
	checkoutProjectReturnsOnCall map[int]struct {
		result1 error
	}
	CommitChangesStub        func(string, string, string, string) error
	commitChangesMutex       sync.RWMutex
	commitChangesArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	commitChangesReturns struct {
		result1 error
	}
	commitChangesReturnsOnCall map[int]struct {
		result1 error
	}
	CreateOBSConfigFileStub        func(string, string) error
	createOBSConfigFileMutex       sync.RWMutex
	createOBSConfigFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createOBSConfigFileReturns struct {
		result1 error
	}
	createOBSConfigFileReturnsOnCall map[int]struct {
		result1 error
	}
	GenerateReleaseVersionStub        func(string, string, string, bool) (*release.Versions, error)
	generateReleaseVersionMutex       sync.RWMutex
	generateReleaseVersionArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 bool
	}
	generateReleaseVersionReturns struct {
		result1 *release.Versions
		result2 error
	}
	generateReleaseVersionReturnsOnCall map[int]struct {
		result1 *release.Versions
		result2 error
	}
	GenerateSpecsAndArtifactsStub        func(*specs.Options) error
	generateSpecsAndArtifactsMutex       sync.RWMutex
	generateSpecsAndArtifactsArgsForCall []struct {
		arg1 *specs.Options
	}
	generateSpecsAndArtifactsReturns struct {
		result1 error
	}
	generateSpecsAndArtifactsReturnsOnCall map[int]struct {
		result1 error
	}
	MkdirAllStub        func(string) error
	mkdirAllMutex       sync.RWMutex
	mkdirAllArgsForCall []struct {
		arg1 string
	}
	mkdirAllReturns struct {
		result1 error
	}
	mkdirAllReturnsOnCall map[int]struct {
		result1 error
	}
	RemovePackageFilesStub        func(string) error
	removePackageFilesMutex       sync.RWMutex
	removePackageFilesArgsForCall []struct {
		arg1 string
	}
	removePackageFilesReturns struct {
		result1 error
	}
	removePackageFilesReturnsOnCall map[int]struct {
		result1 error
	}
	SubmitStub        func(*gcb.Options) error
	submitMutex       sync.RWMutex
	submitArgsForCall []struct {
		arg1 *gcb.Options
	}
	submitReturns struct {
		result1 error
	}
	submitReturnsOnCall map[int]struct {
		result1 error
	}
	WaitStub        func(string, string) error
	waitMutex       sync.RWMutex
	waitArgsForCall []struct {
		arg1 string
		arg2 string
	}
	waitReturns struct {
		result1 error
	}
	waitReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStageImpl) AddRemoveChanges(arg1 string, arg2 string, arg3 string) error {
	fake.addRemoveChangesMutex.Lock()
	ret, specificReturn := fake.addRemoveChangesReturnsOnCall[len(fake.addRemoveChangesArgsForCall)]
	fake.addRemoveChangesArgsForCall = append(fake.addRemoveChangesArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AddRemoveChangesStub
	fakeReturns := fake.addRemoveChangesReturns
	fake.recordInvocation("AddRemoveChanges", []interface{}{arg1, arg2, arg3})
	fake.addRemoveChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStageImpl) AddRemoveChangesCallCount() int {
	fake.addRemoveChangesMutex.RLock()
	defer fake.addRemoveChangesMutex.RUnlock()
	return len(fake.addRemoveChangesArgsForCall)
}

func (fake *FakeStageImpl) AddRemoveChangesCalls(stub func(string, string, string) error) {
	fake.addRemoveChangesMutex.Lock()
	defer fake.addRemoveChangesMutex.Unlock()
	fake.AddRemoveChangesStub = stub
}

func (fake *FakeStageImpl) AddRemoveChangesArgsForCall(i int) (string, string, string) {
	fake.addRemoveChangesMutex.RLock()
	defer fake.addRemoveChangesMutex.RUnlock()
	argsForCall := fake.addRemoveChangesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStageImpl) AddRemoveChangesReturns(result1 error) {
	fake.addRemoveChangesMutex.Lock()
	defer fake.addRemoveChangesMutex.Unlock()
	fake.AddRemoveChangesStub = nil
	fake.addRemoveChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) AddRemoveChangesReturnsOnCall(i int, result1 error) {
	fake.addRemoveChangesMutex.Lock()
	defer fake.addRemoveChangesMutex.Unlock()
	fake.AddRemoveChangesStub = nil
	if fake.addRemoveChangesReturnsOnCall == nil {
		fake.addRemoveChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addRemoveChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) BranchNeedsCreation(arg1 string, arg2 string, arg3 semver.Version) (bool, error) {
	fake.branchNeedsCreationMutex.Lock()
	ret, specificReturn := fake.branchNeedsCreationReturnsOnCall[len(fake.branchNeedsCreationArgsForCall)]
	fake.branchNeedsCreationArgsForCall = append(fake.branchNeedsCreationArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 semver.Version
	}{arg1, arg2, arg3})
	stub := fake.BranchNeedsCreationStub
	fakeReturns := fake.branchNeedsCreationReturns
	fake.recordInvocation("BranchNeedsCreation", []interface{}{arg1, arg2, arg3})
	fake.branchNeedsCreationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStageImpl) BranchNeedsCreationCallCount() int {
	fake.branchNeedsCreationMutex.RLock()
	defer fake.branchNeedsCreationMutex.RUnlock()
	return len(fake.branchNeedsCreationArgsForCall)
}

func (fake *FakeStageImpl) BranchNeedsCreationCalls(stub func(string, string, semver.Version) (bool, error)) {
	fake.branchNeedsCreationMutex.Lock()
	defer fake.branchNeedsCreationMutex.Unlock()
	fake.BranchNeedsCreationStub = stub
}

func (fake *FakeStageImpl) BranchNeedsCreationArgsForCall(i int) (string, string, semver.Version) {
	fake.branchNeedsCreationMutex.RLock()
	defer fake.branchNeedsCreationMutex.RUnlock()
	argsForCall := fake.branchNeedsCreationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStageImpl) BranchNeedsCreationReturns(result1 bool, result2 error) {
	fake.branchNeedsCreationMutex.Lock()
	defer fake.branchNeedsCreationMutex.Unlock()
	fake.BranchNeedsCreationStub = nil
	fake.branchNeedsCreationReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStageImpl) BranchNeedsCreationReturnsOnCall(i int, result1 bool, result2 error) {
	fake.branchNeedsCreationMutex.Lock()
	defer fake.branchNeedsCreationMutex.Unlock()
	fake.BranchNeedsCreationStub = nil
	if fake.branchNeedsCreationReturnsOnCall == nil {
		fake.branchNeedsCreationReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.branchNeedsCreationReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStageImpl) CheckPrerequisites(arg1 string) error {
	fake.checkPrerequisitesMutex.Lock()
	ret, specificReturn := fake.checkPrerequisitesReturnsOnCall[len(fake.checkPrerequisitesArgsForCall)]
	fake.checkPrerequisitesArgsForCall = append(fake.checkPrerequisitesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CheckPrerequisitesStub
	fakeReturns := fake.checkPrerequisitesReturns
	fake.recordInvocation("CheckPrerequisites", []interface{}{arg1})
	fake.checkPrerequisitesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStageImpl) CheckPrerequisitesCallCount() int {
	fake.checkPrerequisitesMutex.RLock()
	defer fake.checkPrerequisitesMutex.RUnlock()
	return len(fake.checkPrerequisitesArgsForCall)
}

func (fake *FakeStageImpl) CheckPrerequisitesCalls(stub func(string) error) {
	fake.checkPrerequisitesMutex.Lock()
	defer fake.checkPrerequisitesMutex.Unlock()
	fake.CheckPrerequisitesStub = stub
}

func (fake *FakeStageImpl) CheckPrerequisitesArgsForCall(i int) string {
	fake.checkPrerequisitesMutex.RLock()
	defer fake.checkPrerequisitesMutex.RUnlock()
	argsForCall := fake.checkPrerequisitesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStageImpl) CheckPrerequisitesReturns(result1 error) {
	fake.checkPrerequisitesMutex.Lock()
	defer fake.checkPrerequisitesMutex.Unlock()
	fake.CheckPrerequisitesStub = nil
	fake.checkPrerequisitesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) CheckPrerequisitesReturnsOnCall(i int, result1 error) {
	fake.checkPrerequisitesMutex.Lock()
	defer fake.checkPrerequisitesMutex.Unlock()
	fake.CheckPrerequisitesStub = nil
	if fake.checkPrerequisitesReturnsOnCall == nil {
		fake.checkPrerequisitesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkPrerequisitesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) CheckoutProject(arg1 string, arg2 string) error {
	fake.checkoutProjectMutex.Lock()
	ret, specificReturn := fake.checkoutProjectReturnsOnCall[len(fake.checkoutProjectArgsForCall)]
	fake.checkoutProjectArgsForCall = append(fake.checkoutProjectArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CheckoutProjectStub
	fakeReturns := fake.checkoutProjectReturns
	fake.recordInvocation("CheckoutProject", []interface{}{arg1, arg2})
	fake.checkoutProjectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStageImpl) CheckoutProjectCallCount() int {
	fake.checkoutProjectMutex.RLock()
	defer fake.checkoutProjectMutex.RUnlock()
	return len(fake.checkoutProjectArgsForCall)
}

func (fake *FakeStageImpl) CheckoutProjectCalls(stub func(string, string) error) {
	fake.checkoutProjectMutex.Lock()
	defer fake.checkoutProjectMutex.Unlock()
	fake.CheckoutProjectStub = stub
}

func (fake *FakeStageImpl) CheckoutProjectArgsForCall(i int) (string, string) {
	fake.checkoutProjectMutex.RLock()
	defer fake.checkoutProjectMutex.RUnlock()
	argsForCall := fake.checkoutProjectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStageImpl) CheckoutProjectReturns(result1 error) {
	fake.checkoutProjectMutex.Lock()
	defer fake.checkoutProjectMutex.Unlock()
	fake.CheckoutProjectStub = nil
	fake.checkoutProjectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) CheckoutProjectReturnsOnCall(i int, result1 error) {
	fake.checkoutProjectMutex.Lock()
	defer fake.checkoutProjectMutex.Unlock()
	fake.CheckoutProjectStub = nil
	if fake.checkoutProjectReturnsOnCall == nil {
		fake.checkoutProjectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkoutProjectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) CommitChanges(arg1 string, arg2 string, arg3 string, arg4 string) error {
	fake.commitChangesMutex.Lock()
	ret, specificReturn := fake.commitChangesReturnsOnCall[len(fake.commitChangesArgsForCall)]
	fake.commitChangesArgsForCall = append(fake.commitChangesArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.CommitChangesStub
	fakeReturns := fake.commitChangesReturns
	fake.recordInvocation("CommitChanges", []interface{}{arg1, arg2, arg3, arg4})
	fake.commitChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStageImpl) CommitChangesCallCount() int {
	fake.commitChangesMutex.RLock()
	defer fake.commitChangesMutex.RUnlock()
	return len(fake.commitChangesArgsForCall)
}

func (fake *FakeStageImpl) CommitChangesCalls(stub func(string, string, string, string) error) {
	fake.commitChangesMutex.Lock()
	defer fake.commitChangesMutex.Unlock()
	fake.CommitChangesStub = stub
}

func (fake *FakeStageImpl) CommitChangesArgsForCall(i int) (string, string, string, string) {
	fake.commitChangesMutex.RLock()
	defer fake.commitChangesMutex.RUnlock()
	argsForCall := fake.commitChangesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStageImpl) CommitChangesReturns(result1 error) {
	fake.commitChangesMutex.Lock()
	defer fake.commitChangesMutex.Unlock()
	fake.CommitChangesStub = nil
	fake.commitChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) CommitChangesReturnsOnCall(i int, result1 error) {
	fake.commitChangesMutex.Lock()
	defer fake.commitChangesMutex.Unlock()
	fake.CommitChangesStub = nil
	if fake.commitChangesReturnsOnCall == nil {
		fake.commitChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.commitChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) CreateOBSConfigFile(arg1 string, arg2 string) error {
	fake.createOBSConfigFileMutex.Lock()
	ret, specificReturn := fake.createOBSConfigFileReturnsOnCall[len(fake.createOBSConfigFileArgsForCall)]
	fake.createOBSConfigFileArgsForCall = append(fake.createOBSConfigFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateOBSConfigFileStub
	fakeReturns := fake.createOBSConfigFileReturns
	fake.recordInvocation("CreateOBSConfigFile", []interface{}{arg1, arg2})
	fake.createOBSConfigFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStageImpl) CreateOBSConfigFileCallCount() int {
	fake.createOBSConfigFileMutex.RLock()
	defer fake.createOBSConfigFileMutex.RUnlock()
	return len(fake.createOBSConfigFileArgsForCall)
}

func (fake *FakeStageImpl) CreateOBSConfigFileCalls(stub func(string, string) error) {
	fake.createOBSConfigFileMutex.Lock()
	defer fake.createOBSConfigFileMutex.Unlock()
	fake.CreateOBSConfigFileStub = stub
}

func (fake *FakeStageImpl) CreateOBSConfigFileArgsForCall(i int) (string, string) {
	fake.createOBSConfigFileMutex.RLock()
	defer fake.createOBSConfigFileMutex.RUnlock()
	argsForCall := fake.createOBSConfigFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStageImpl) CreateOBSConfigFileReturns(result1 error) {
	fake.createOBSConfigFileMutex.Lock()
	defer fake.createOBSConfigFileMutex.Unlock()
	fake.CreateOBSConfigFileStub = nil
	fake.createOBSConfigFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) CreateOBSConfigFileReturnsOnCall(i int, result1 error) {
	fake.createOBSConfigFileMutex.Lock()
	defer fake.createOBSConfigFileMutex.Unlock()
	fake.CreateOBSConfigFileStub = nil
	if fake.createOBSConfigFileReturnsOnCall == nil {
		fake.createOBSConfigFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createOBSConfigFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) GenerateReleaseVersion(arg1 string, arg2 string, arg3 string, arg4 bool) (*release.Versions, error) {
	fake.generateReleaseVersionMutex.Lock()
	ret, specificReturn := fake.generateReleaseVersionReturnsOnCall[len(fake.generateReleaseVersionArgsForCall)]
	fake.generateReleaseVersionArgsForCall = append(fake.generateReleaseVersionArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.GenerateReleaseVersionStub
	fakeReturns := fake.generateReleaseVersionReturns
	fake.recordInvocation("GenerateReleaseVersion", []interface{}{arg1, arg2, arg3, arg4})
	fake.generateReleaseVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStageImpl) GenerateReleaseVersionCallCount() int {
	fake.generateReleaseVersionMutex.RLock()
	defer fake.generateReleaseVersionMutex.RUnlock()
	return len(fake.generateReleaseVersionArgsForCall)
}

func (fake *FakeStageImpl) GenerateReleaseVersionCalls(stub func(string, string, string, bool) (*release.Versions, error)) {
	fake.generateReleaseVersionMutex.Lock()
	defer fake.generateReleaseVersionMutex.Unlock()
	fake.GenerateReleaseVersionStub = stub
}

func (fake *FakeStageImpl) GenerateReleaseVersionArgsForCall(i int) (string, string, string, bool) {
	fake.generateReleaseVersionMutex.RLock()
	defer fake.generateReleaseVersionMutex.RUnlock()
	argsForCall := fake.generateReleaseVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStageImpl) GenerateReleaseVersionReturns(result1 *release.Versions, result2 error) {
	fake.generateReleaseVersionMutex.Lock()
	defer fake.generateReleaseVersionMutex.Unlock()
	fake.GenerateReleaseVersionStub = nil
	fake.generateReleaseVersionReturns = struct {
		result1 *release.Versions
		result2 error
	}{result1, result2}
}

func (fake *FakeStageImpl) GenerateReleaseVersionReturnsOnCall(i int, result1 *release.Versions, result2 error) {
	fake.generateReleaseVersionMutex.Lock()
	defer fake.generateReleaseVersionMutex.Unlock()
	fake.GenerateReleaseVersionStub = nil
	if fake.generateReleaseVersionReturnsOnCall == nil {
		fake.generateReleaseVersionReturnsOnCall = make(map[int]struct {
			result1 *release.Versions
			result2 error
		})
	}
	fake.generateReleaseVersionReturnsOnCall[i] = struct {
		result1 *release.Versions
		result2 error
	}{result1, result2}
}

func (fake *FakeStageImpl) GenerateSpecsAndArtifacts(arg1 *specs.Options) error {
	fake.generateSpecsAndArtifactsMutex.Lock()
	ret, specificReturn := fake.generateSpecsAndArtifactsReturnsOnCall[len(fake.generateSpecsAndArtifactsArgsForCall)]
	fake.generateSpecsAndArtifactsArgsForCall = append(fake.generateSpecsAndArtifactsArgsForCall, struct {
		arg1 *specs.Options
	}{arg1})
	stub := fake.GenerateSpecsAndArtifactsStub
	fakeReturns := fake.generateSpecsAndArtifactsReturns
	fake.recordInvocation("GenerateSpecsAndArtifacts", []interface{}{arg1})
	fake.generateSpecsAndArtifactsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStageImpl) GenerateSpecsAndArtifactsCallCount() int {
	fake.generateSpecsAndArtifactsMutex.RLock()
	defer fake.generateSpecsAndArtifactsMutex.RUnlock()
	return len(fake.generateSpecsAndArtifactsArgsForCall)
}

func (fake *FakeStageImpl) GenerateSpecsAndArtifactsCalls(stub func(*specs.Options) error) {
	fake.generateSpecsAndArtifactsMutex.Lock()
	defer fake.generateSpecsAndArtifactsMutex.Unlock()
	fake.GenerateSpecsAndArtifactsStub = stub
}

func (fake *FakeStageImpl) GenerateSpecsAndArtifactsArgsForCall(i int) *specs.Options {
	fake.generateSpecsAndArtifactsMutex.RLock()
	defer fake.generateSpecsAndArtifactsMutex.RUnlock()
	argsForCall := fake.generateSpecsAndArtifactsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStageImpl) GenerateSpecsAndArtifactsReturns(result1 error) {
	fake.generateSpecsAndArtifactsMutex.Lock()
	defer fake.generateSpecsAndArtifactsMutex.Unlock()
	fake.GenerateSpecsAndArtifactsStub = nil
	fake.generateSpecsAndArtifactsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) GenerateSpecsAndArtifactsReturnsOnCall(i int, result1 error) {
	fake.generateSpecsAndArtifactsMutex.Lock()
	defer fake.generateSpecsAndArtifactsMutex.Unlock()
	fake.GenerateSpecsAndArtifactsStub = nil
	if fake.generateSpecsAndArtifactsReturnsOnCall == nil {
		fake.generateSpecsAndArtifactsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.generateSpecsAndArtifactsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) MkdirAll(arg1 string) error {
	fake.mkdirAllMutex.Lock()
	ret, specificReturn := fake.mkdirAllReturnsOnCall[len(fake.mkdirAllArgsForCall)]
	fake.mkdirAllArgsForCall = append(fake.mkdirAllArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.MkdirAllStub
	fakeReturns := fake.mkdirAllReturns
	fake.recordInvocation("MkdirAll", []interface{}{arg1})
	fake.mkdirAllMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStageImpl) MkdirAllCallCount() int {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return len(fake.mkdirAllArgsForCall)
}

func (fake *FakeStageImpl) MkdirAllCalls(stub func(string) error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = stub
}

func (fake *FakeStageImpl) MkdirAllArgsForCall(i int) string {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	argsForCall := fake.mkdirAllArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStageImpl) MkdirAllReturns(result1 error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = nil
	fake.mkdirAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) MkdirAllReturnsOnCall(i int, result1 error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = nil
	if fake.mkdirAllReturnsOnCall == nil {
		fake.mkdirAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) RemovePackageFiles(arg1 string) error {
	fake.removePackageFilesMutex.Lock()
	ret, specificReturn := fake.removePackageFilesReturnsOnCall[len(fake.removePackageFilesArgsForCall)]
	fake.removePackageFilesArgsForCall = append(fake.removePackageFilesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemovePackageFilesStub
	fakeReturns := fake.removePackageFilesReturns
	fake.recordInvocation("RemovePackageFiles", []interface{}{arg1})
	fake.removePackageFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStageImpl) RemovePackageFilesCallCount() int {
	fake.removePackageFilesMutex.RLock()
	defer fake.removePackageFilesMutex.RUnlock()
	return len(fake.removePackageFilesArgsForCall)
}

func (fake *FakeStageImpl) RemovePackageFilesCalls(stub func(string) error) {
	fake.removePackageFilesMutex.Lock()
	defer fake.removePackageFilesMutex.Unlock()
	fake.RemovePackageFilesStub = stub
}

func (fake *FakeStageImpl) RemovePackageFilesArgsForCall(i int) string {
	fake.removePackageFilesMutex.RLock()
	defer fake.removePackageFilesMutex.RUnlock()
	argsForCall := fake.removePackageFilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStageImpl) RemovePackageFilesReturns(result1 error) {
	fake.removePackageFilesMutex.Lock()
	defer fake.removePackageFilesMutex.Unlock()
	fake.RemovePackageFilesStub = nil
	fake.removePackageFilesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) RemovePackageFilesReturnsOnCall(i int, result1 error) {
	fake.removePackageFilesMutex.Lock()
	defer fake.removePackageFilesMutex.Unlock()
	fake.RemovePackageFilesStub = nil
	if fake.removePackageFilesReturnsOnCall == nil {
		fake.removePackageFilesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removePackageFilesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) Submit(arg1 *gcb.Options) error {
	fake.submitMutex.Lock()
	ret, specificReturn := fake.submitReturnsOnCall[len(fake.submitArgsForCall)]
	fake.submitArgsForCall = append(fake.submitArgsForCall, struct {
		arg1 *gcb.Options
	}{arg1})
	stub := fake.SubmitStub
	fakeReturns := fake.submitReturns
	fake.recordInvocation("Submit", []interface{}{arg1})
	fake.submitMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStageImpl) SubmitCallCount() int {
	fake.submitMutex.RLock()
	defer fake.submitMutex.RUnlock()
	return len(fake.submitArgsForCall)
}

func (fake *FakeStageImpl) SubmitCalls(stub func(*gcb.Options) error) {
	fake.submitMutex.Lock()
	defer fake.submitMutex.Unlock()
	fake.SubmitStub = stub
}

func (fake *FakeStageImpl) SubmitArgsForCall(i int) *gcb.Options {
	fake.submitMutex.RLock()
	defer fake.submitMutex.RUnlock()
	argsForCall := fake.submitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStageImpl) SubmitReturns(result1 error) {
	fake.submitMutex.Lock()
	defer fake.submitMutex.Unlock()
	fake.SubmitStub = nil
	fake.submitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) SubmitReturnsOnCall(i int, result1 error) {
	fake.submitMutex.Lock()
	defer fake.submitMutex.Unlock()
	fake.SubmitStub = nil
	if fake.submitReturnsOnCall == nil {
		fake.submitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.submitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) Wait(arg1 string, arg2 string) error {
	fake.waitMutex.Lock()
	ret, specificReturn := fake.waitReturnsOnCall[len(fake.waitArgsForCall)]
	fake.waitArgsForCall = append(fake.waitArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.WaitStub
	fakeReturns := fake.waitReturns
	fake.recordInvocation("Wait", []interface{}{arg1, arg2})
	fake.waitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStageImpl) WaitCallCount() int {
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	return len(fake.waitArgsForCall)
}

func (fake *FakeStageImpl) WaitCalls(stub func(string, string) error) {
	fake.waitMutex.Lock()
	defer fake.waitMutex.Unlock()
	fake.WaitStub = stub
}

func (fake *FakeStageImpl) WaitArgsForCall(i int) (string, string) {
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	argsForCall := fake.waitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStageImpl) WaitReturns(result1 error) {
	fake.waitMutex.Lock()
	defer fake.waitMutex.Unlock()
	fake.WaitStub = nil
	fake.waitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) WaitReturnsOnCall(i int, result1 error) {
	fake.waitMutex.Lock()
	defer fake.waitMutex.Unlock()
	fake.WaitStub = nil
	if fake.waitReturnsOnCall == nil {
		fake.waitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStageImpl) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addRemoveChangesMutex.RLock()
	defer fake.addRemoveChangesMutex.RUnlock()
	fake.branchNeedsCreationMutex.RLock()
	defer fake.branchNeedsCreationMutex.RUnlock()
	fake.checkPrerequisitesMutex.RLock()
	defer fake.checkPrerequisitesMutex.RUnlock()
	fake.checkoutProjectMutex.RLock()
	defer fake.checkoutProjectMutex.RUnlock()
	fake.commitChangesMutex.RLock()
	defer fake.commitChangesMutex.RUnlock()
	fake.createOBSConfigFileMutex.RLock()
	defer fake.createOBSConfigFileMutex.RUnlock()
	fake.generateReleaseVersionMutex.RLock()
	defer fake.generateReleaseVersionMutex.RUnlock()
	fake.generateSpecsAndArtifactsMutex.RLock()
	defer fake.generateSpecsAndArtifactsMutex.RUnlock()
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	fake.removePackageFilesMutex.RLock()
	defer fake.removePackageFilesMutex.RUnlock()
	fake.submitMutex.RLock()
	defer fake.submitMutex.RUnlock()
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStageImpl) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
